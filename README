oren503
ogetzler



=============================
=      File description     =
=============================
oop.ex6/main/Sjavac:
This class is a s-Java verifier - a tool able to verify the validity of s-Java code.

oop.ex6/main/SjavacReader.java:
This class reads a line of sjava file and redirects it to the appropriate parser.

oop.ex6/main/Method.java:
This class represent a sjava method.

oop.ex6/main/Variable.java:
This class represent a sjava variable.

oop.ex6/main/InvalidUsageException.java:
This class represents an invalid usage exception, e.g. Sjavac receives more than one argument.

oop.ex6/parsesjava/SjavaParser.java:
This class represents a sjava parser which is able to parse different components of the sjava file.

oop.ex6/parsesjava/MethodsParser.java:
Goes over different methods, and tests whether or not they are legal.

oop.ex6/parsesjava/VariableParser.java:
This class receives a variable line, parses it and extricates from her the variables.

oop.ex6/parsesjava/IllegalLineException.java:
This class represent an illegal line exception.



=============================
=          Design           =
=============================
We used an abstract class named "SjavaParser" which is able to parse different components of
the sjava file. The classes "MethodsParser" and "VariableParser" have a "is-a" relation with it.
We thought that an abstract class would best fit our program for the following reasons:
* "MethodParser" and "VariableParser" are two kinds of the same thing - "SjavaParser".
* "SjavaParser" uses an abstract method.
* An instance of "SjavaParser" doesn't make any sense.




=============================
=  Implementation details   =
=============================
1) We used a Deque - "variablesStack" to keep track of the different scopes. E.g. the first element
   represents the global scope, the second element represent a method's local scope, the third element
   can represent a while scope and so on.

2) We used recursion in the "MethodsParser" class to handle the if\while block.




=============================
=    Answers to questions   =
=============================
Q: How you handled s-Java code errors, and why you chose to do so?
A: We handled s-Java code errors by using the exception mechanism. This way, we can easily propagate
   errors up the call stack. In addition, it helps separating error handling code from the rest of the code.

Q: How would you modify your code to add new types of variables (e.g. float)?
A: We would add the new types to the field "LEGAL_TYPE" which belongs to the class "VariableParser".

Q: Which modifications/extensions you would have to make in your code in order to support
   the following features?
A: * Classes:
     We would extend the code by adding a new class - "ClassParser", which will also inherit from
     SjavaParser. Additionally, it will use "MethodsParser" And "VariableParser" to parse
     methods and variables
   * Different method's types:
     We would add the new types to the field "LEGAL_METHOD_TYPE" which belongs to the class "MethodsParser",
     and make sure that the "checkReturn" method supports the new types.

Q: What are the two main regular expressions you used in your code?
A: 1) Check if a method's signature is legal - "[ \t]*+void[ \t]*+([a-zA-Z]+[_0-9]*)[ \t]*+\\(".
   2) Check if a variable's name is legal - "[ \t]*+(?:[a-zA-Z_][a-zA-Z0-9]++|[a-zA-Z])[\\w]*+".
